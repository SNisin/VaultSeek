<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Search</title>
    <style>
        #searchResults {
            display: inline-block;
            /* padding: 1em; */
            margin-top: 30px;
            /* Adjust based on nav height */
            margin-bottom: 50px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            /* table-layout: fixed; */
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 1px 8px;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        th {
            background-color: #f4f4f4;
            position: relative;
            cursor: grab;
            user-select: none;
        }

        tr {
            content-visibility: hidden;
            contain-intrinsic-block-size: auto 1em;
        }

        th:active {
            cursor: grabbing;
        }

        .resizer {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            cursor: col-resize;
            user-select: none;
        }

        .resizer:hover,
        .resizing {
            border-right: 2px solid blue;
        }

        .dragging {
            background-color: #f0f0f0;
        }



        .sortable {
            cursor: pointer;
            user-select: none;
        }

        .sortable:hover {
            background-color: #e0e0e0;
        }

        .ascending.sortable::after {
            content: " ↑";
            font-size: 0.8em;
        }

        .descending.sortable::after {
            content: " ↓";
            font-size: 0.8em;
        }

        body {
            overflow-x: auto;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin: 8px;
        }

        nav {
            /* always on top */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #f4f4f4;
            padding: 0 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 100%;
        }

        nav input {
            padding: 5px;
            width: 100%;
        }

        /* table headers also sticky just below the nav */
        .resizableTable thead {
            position: sticky;
            top: 30px;
            /* Adjust based on nav height */
            z-index: 999;
            /* Ensure headers are above other content */
        }

        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #f4f4f4;
            padding: 4px 8px;
            text-align: left;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        footer p {
            margin: 0;
            font-size: 12px;
            display: inline-block;
            margin-right: 20px;
        }

        * {
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <nav>
        <input type="text" id="searchInput" placeholder="Search files..." oninput="filterFiles()">
    </nav>
    <div id="searchResults">
        <table class="resizableTable">
            <thead>
                <tr>
                    <th id="nameHeader" class="sortable">
                        Name <span id="nameSortIndicator"></span>
                    </th>
                    <th>Path</th>
                    <th id="sizeHeader" class="sortable">Size</th>
                    <th id="lastModifiedHeader" class="sortable">Last Modified</th>
                    <th id="createdHeader" class="sortable">Created</th>
                    <th id="AttributesHeader" class="sortable">Attributes</th>
                </tr>
            </thead>
            <tbody id="fileTableBody">
                <!-- File rows will be dynamically added here -->
            </tbody>
        </table>
    </div>
    <footer>
        <p id="numResults"><span id="totalResultsCount">0</span> Elements</p>
        <p id="timeTaken">Time taken: <span id="timeTakenVal">0</span> ms</p>
    </footer>
    <script>

        const fileEndingsMap = {
            "jpg": "picture",
            "png": "picture",
            "gif": "picture",
            "bmp": "picture",
            "svg": "picture",
            "webp": "picture",
            "mp3": "music",
            "mp4": "video",
            "avi": "video",
            "mkv": "video",
            "txt": "text",
            "pdf": "document",
            "docx": "document",

        }

        function timestampToLocaleString(timestamp) {
            if (timestamp === null || timestamp === undefined) return '';
            return new Date(Number(timestamp) / 10000 + Date.UTC(1601, 0, 1)).toLocaleString()
        }
        function formatSize(size) {
            if (size === null || size === undefined) return '';
            if (size < 1024) return `${size} B`;
            else if (size < 1024 * 1024) return `${(size / 1024).toLocaleString(undefined, { maximumFractionDigits: 2 })} KiB`;
            else if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toLocaleString(undefined, { maximumFractionDigits: 2 })} MiB`;
            else return `${(size / (1024 * 1024 * 1024)).toLocaleString(undefined, { maximumFractionDigits: 2 })} GiB`;
        }
        function formatSizeAsBytes(size) {
            if (size === null || size === undefined) return '';
            // add thousand separators for the correct locale
            return size.toLocaleString() + ' B';



        }
        const attributes = {
            1: { long: 'Read-only', short: 'R' },
            2: { long: 'Hidden', short: 'H' },
            4: { long: 'System', short: 'S' },
            16: { long: 'Directory', short: 'D' },
            32: { long: 'Archive', short: 'A' },
            128: { long: 'Normal', short: 'N' },
            256: { long: 'Temporary', short: 'T' },
            512: { long: 'Sparse file', short: 'P' },
            1024: { long: 'Reparse point', short: 'L' },
            2048: { long: 'Compressed', short: 'C' },
            4096: { long: 'Offline', short: 'O' },
            8192: { long: 'Not content indexed', short: 'I' },
            16384: { long: 'Encrypted', short: 'E' }
        };
        function attributeBitmapToString(attribute, long) {
            if (attribute === 0) return '-';
            let attrString = '';
            for (const [key, value] of Object.entries(attributes)) {
                if (attribute & key) {
                    attrString += long ? value.long + `(${value.short}) ` : value.short;
                }
            }
            return attrString.trim() || '-';
        }
        function createRow(file) {
            const row = document.createElement('tr');
            row.innerHTML = `
                    <td title="${file.name}">
                        <img src="icons/${getFileType(file)}.svg" alt="${getFileType(file)}" style="height: 1em; vertical-align: middle; margin-right: 0.5em;">
                        ${file.name}
                    </td>
                    <td title="${file.path}">${file.path}</td>
                    <td title="${formatSizeAsBytes(file.size)}">${formatSize(file.size)}</td>
                    <td>${timestampToLocaleString(file["date_modified"])}</td>
                    <td>${timestampToLocaleString(file["date_created"])}</td>
                    <td title="${attributeBitmapToString(file["attributes"], true)}">${attributeBitmapToString(file["attributes"], false)}</td>
                `;
            return row;
        }
        let fileData = [];
        let currentOffset = 0;
        let pageSize = 100; // Number of files to display per page
        let totalResults = 0;

        function displayFiles() {
            const tableBody = document.getElementById('fileTableBody');
            tableBody.innerHTML = ''; // Clear existing rows

            fileData.forEach(file => {
                tableBody.appendChild(createRow(file));
            });

        }
        function appendFiles(newFiles) {
            const tableBody = document.getElementById('fileTableBody');

            newFiles.forEach(file => {
                tableBody.appendChild(createRow(file));
            });
        }
        function getFileType(file) {
            if (file["attributes"] & 16) {
                return "folder";
            }
            const ext = file["name"].split('.').pop().toLowerCase();
            return fileEndingsMap[ext] || "file";
        }


        let sortBy = null;
        let sortOrder = "ascending";
        function filterFiles() {
            const searchInput = document.getElementById('searchInput').value.toLowerCase();
            isFetching = true;
            fetch(`/search?query=${searchInput}` + (sortBy ? `&sort_by=${sortBy}&sort_order=${sortOrder}` : ''))
                .then(response => response.json())
                .then(data => {
                    fileData = data.results;
                    totalResults = data.total;
                    pageSize = data.page_size;
                    currentOffset = data.offset;

                    document.getElementById('totalResultsCount').textContent = totalResults.toLocaleString();
                    document.getElementById('timeTakenVal').textContent = (data.time_taken / 1000).toLocaleString(undefined, { maximumFractionDigits: 2 });

                    displayFiles();

                    const table = document.querySelector('.resizableTable');
                    if (table && !table.classList.contains('resConfigured')) {
                        createResizableTable(table);
                    }
                    isFetching = false;
                })
                .catch(error => console.error('Error fetching files:', error));
        }
        let isFetching = false;
        // if scrolling, fetch more files
        document.addEventListener('scroll', function () {
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
            const clientHeight = document.documentElement.clientHeight || document.body.clientHeight;

            // If scrolled to the bottom, fetch more files
            if (scrollTop + clientHeight >= scrollHeight - 10) {
                if (!isFetching && fileData.length < totalResults) {
                    isFetching = true;
                    currentOffset += pageSize; // Increment offset by page size
                    fetch(`/search?query=${document.getElementById('searchInput').value.toLowerCase()}&offset=${currentOffset}&page_size=${pageSize}` + (sortBy ? `&sort_by=${sortBy}&sort_order=${sortOrder}` : ''))
                        .then(response => response.json())
                        .then(data => {
                            fileData = fileData.concat(data.results);
                            appendFiles(data.results);
                            isFetching = false;
                        })
                        .catch(error => console.error('Error fetching more files:', error));
                }
            }
        });

        const sortFieldMap = {
            "nameHeader": "filename",
            "sizeHeader": "size",
            "lastModifiedHeader": "date_modified",
            "createdHeader": "date_created",
        }
        const reverseSortFieldMap = Object.fromEntries(Object.entries(sortFieldMap).map(([k, v]) => [v, k]));


        function toggleSortBy(field) {
            console.log(`Toggling sort by: ${field}`);
            if (sortBy === field) {
                sortOrder = sortOrder === 'ascending' ? 'descending' : 'ascending';
            } else {
                sortBy = field;
                sortOrder = 'ascending';
            }

            // Update the class on the header to indicate sorting direction
            const headers = document.querySelectorAll('.sortable');
            headers.forEach(header => {
                header.classList.remove('ascending', 'descending');
            });
            const currentHeader = document.getElementById(reverseSortFieldMap[sortBy]);
            if (currentHeader) {
                currentHeader.classList.add(sortOrder);
            }

            filterFiles();
        }

        document.querySelectorAll('.sortable').forEach(header => {
            header.addEventListener('click', (e) => {
                // If not clicked on the resizer, toggle sort
                if (e.target.classList.contains('resizer')) return;
                const field = sortFieldMap[header.id];
                if (field) {
                    toggleSortBy(field);
                }
            });
        });

        const createResizableTable = function (table) {
            const cols = table.querySelectorAll('th');
            [].forEach.call(cols, function (col) {
                // Add a resizer element to the column
                const resizer = document.createElement('div');
                resizer.classList.add('resizer');


                // Set the height
                resizer.style.height = `${table.offsetHeight}px`;


                col.appendChild(resizer);


                createResizableColumn(col, resizer);

            });
            table.style.tableLayout = 'fixed'; // Ensure table layout is fixed for proper resizing
            table.classList.add('resConfigured'); // Mark the table as configured
            // Compute the total width of the table
            const totalWidth = Array.from(table.querySelectorAll('th')).reduce((total, th) => {
                return total + parseInt(th.style.width, 10);
            }, 0);
            // Set the width of the table to the total width
            table.style.width = `${totalWidth}px`;
        };


        const createResizableColumn = function (col, resizer) {
            let x = 0;
            let w = 0;

            // Explicitly set the width of each column from computed styles
            const styles = window.getComputedStyle(col);
            console.log('Column styles:', styles.width);
            col.style.width = styles.width;


            const mouseDownHandler = function (e) {

                x = e.clientX;


                const styles = window.getComputedStyle(col);
                w = parseInt(styles.width, 10);


                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);


                resizer.classList.add('resizing');
            };


            const mouseMoveHandler = function (e) {
                console.log('Mouse down on resizer');
                console.log(e);
                const dx = e.clientX - x;
                col.style.width = `${w + dx}px`;

                // Compute the total width of the table
                const table = col.closest('table');
                const totalWidth = Array.from(table.querySelectorAll('th')).reduce((total, th) => {
                    return total + parseInt(th.style.width, 10);
                }, 0);
                // Set the width of the table to the total width
                table.style.width = `${totalWidth}px`;
            };


            const mouseUpHandler = function () {
                resizer.classList.remove('resizing');
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
            };


            resizer.addEventListener('mousedown', mouseDownHandler);
        };



        // Fetch files on page load
        filterFiles();

    </script>
</body>

</html>
